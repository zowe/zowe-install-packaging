name: Zowe CICD Integration Tests
on:   
  workflow_dispatch:
    inputs:
      test-server:
        description: 'Choose Test Server'
        type: choice
        required: true
        default: 'Any zzow servers'
        options: 
          - Any zzow servers
          - zzow02
          - zzow03
          - zzow04
          - zzow02,zzow03,zzow04
      install-test:
        description: 'Choose Install Test'
        type: choice
        required: true
        default: Convenience Pax
        options:
          - Convenience Pax
          - SMPE FMID
          - SMPE PTF
          - Extensions
          - Keyring
          - z/OS node v12
          - z/OS node v14
          - z/OS node v16
          - Non-strict Verify External Certificate
          - Install PTF Twice
          - Generate API Documentation
          - Zowe Nightly Tests
          - Zowe Release Tests
      custom-zowe-artifactory-pattern-or-build-number:
        description: 'Custom Zowe Artifactory Pattern or Build Number:'
        required: false
      custom-zowe-cli-artifactory-pattern:
        description: 'Custom Zowe CLI Artifactory Pattern:'
        required: false
      custom-extension-list:
        description: 'Custom Extension List:'
        required: false
        default: 'sample-node-api;sample-trial-app'
      RANDOM_DISPATCH_EVENT_ID:
        description: 'random dispatch event id'
        required: false
        type: string

# create a new branch to overwrite following defaults if necessary
env:
  # constants
  INSTALL_TEST_PATH: tests/installation
  SANITY_TEST_PATH: tests/sanity
  DEFAULT_ZOWE_PAX_ARTIFACTORY_PATTERN: libs-snapshot-local/org/zowe/*zowe*{branch-name}*.pax
  DEFAULT_ZOWE_SMPE_ARTIFACTORY_PATTERN: libs-snapshot-local/org/zowe/*zowe-smpe*{branch-name}*.zip
  DEFAULT_ZOWE_CLI_ARTIFACTORY_PATTERN: PLACE_HOLDER/org/zowe/cli/zowe-cli-package/next/zowe-cli-package-next-*.zip
  DEFAULT_ZOWE_EXT_ARTIFACTORY_PATTERN: libs-snapshot-local/org/zowe/{ext-name}/*/{ext-name}-*.pax

  # can be overwritten, adjusted by DevOps only
  ZOS_NODE_VERSION: v12.18.4
  # ZOS_NODE_VERSION more to choose from: v14.15.1, v16.13.0
  CLIENT_NODE_VERSION: v12.18.3
  INSTALL_TEST_DEBUG_INFORMATION: zowe-install-test:*
  SANITY_TEST_DEBUG_INFORMATION: zowe-sanity-test:*

  # catalogue of files associated with install test configurations
  CONVENIENCE_PAX_TESTFILE: basic/install.ts
  SMPE_FMID_TESTFILE: basic/install-fmid.ts
  SMPE_PTF_TESTFILE: basic/install-ptf.ts
  EXTENSIONS_TESTFILE: basic/install-ext.ts
  KEYRING_TESTFILE: extended/keyring.ts
  ZOS_NODE_V12_TESTFILE: extended/node-versions/node-v12.ts
  ZOS_NODE_V14_TESTFILE: extended/node-versions/node-v14.ts
  ZOS_NODE_V16_TESTFILE: extended/node-versions/node-v16.ts
  NON_STRICT_VERIFY_EXTERNAL_CERTIFICATE_TESTFILE: extended/certificates/nonstrict-verify-external-certificate.ts
  INSTALL_PTF_TWICE_TESTFILE: extended/install-ptf-two-times.ts
  GENERAL_API_DOCUMENTATION_TESTFILE: basic/install-api-gen.ts
  # FIXME: after Zowe v2 started to build PTF, this should be changed back to install-ptf.ts
  ZOWE_RELEAE_TESTS_FULL: basic/install.ts(zzow02,zzow03,zzow04);basic/install-fmid.ts(zzow02,zzow03,zzow04);basic/install-ext.ts(zzow03);extended/keyring.ts(zzow02,zzow03,zzow04);extended/node-versions/node-v8.ts(zzow02,zzow03,zzow04);extended/node-versions/node-v12.ts(zzow02,zzow03,zzow04);extended/node-versions/node-v14.ts(zzow02,zzow03,zzow04);extended/certificates/nonstrict-verify-external-certificate.ts(zzow02)
  ZOWE_NIGHTLY_TESTS_FULL: basic/install.ts(zzow02,zzow03,zzow04);basic/install-fmid.ts(zzow02,zzow03,zzow04)

jobs:
  display-dispatch-event-id:
    if: github.event.inputs.RANDOM_DISPATCH_EVENT_ID != ''
    runs-on: ubuntu-latest
    steps:
      - name: RANDOM_DISPATCH_EVENT_ID is ${{ github.event.inputs.RANDOM_DISPATCH_EVENT_ID }}
        run: echo "prints random dispatch event id sent from workflow dispatch event"

  check-permission:
    runs-on: ubuntu-latest
    steps:
      # this action will fail the whole workflow if permission check fails
      - name: check permission
        uses: zowe-actions/shared-actions/permission-check@main
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

  make-matrix:
    runs-on: ubuntu-latest
    needs: check-permission
    steps:
    - name: make test matrix
      id: set-matrix
      run: | 
        test_server="${{ github.event.inputs.test-server }}"
        install_test_choice="${{ github.event.inputs.install-test }}"
        case $install_test_choice in

          "Convenience Pax")
            test_file="${{ env.CONVENIENCE_PAX_TESTFILE }}"
            ;;

          "SMPE FMID")
            test_file="${{ env.SMPE_FMID_TESTFILE }}"
            ;;

          "SMPE PTF")
            test_file="${{ env.SMPE_PTF_TESTFILE }}"
            ;;

          "Extensions")
            test_file="${{ env.EXTENSIONS_TESTFILE }}"
            ;;

          "Keyring")
            test_file="${{ env.KEYRING_TESTFILE }}"
            ;;
          
          "z/OS node v12")
            test_file="${{ env.ZOS_NODE_V12_TESTFILE }}"
            ;;

          "z/OS node v14")
            test_file="${{ env.ZOS_NODE_V14_TESTFILE }}"
            ;;

          "z/OS node v16")
            test_file="${{ env.ZOS_NODE_V16_TESTFILE }}"
            ;;

          "Non-strict Verify External Certificate")
            test_file="${{ env.NON_STRICT_VERIFY_EXTERNAL_CERTIFICATE_TESTFILE }}"
            ;;

          "Install PTF Twice")
            test_file="${{ env.INSTALL_PTF_TWICE_TESTFILE }}"
            ;;

          "Generate API Documentation")
            test_file="${{ env.GENERAL_API_DOCUMENTATION_TESTFILE }}"
            ;;
          
          "Zowe Nightly Tests")
            test_file="${{ env.ZOWE_NIGHTLY_TESTS_FULL }}"
            dont_parse_test_server=true
            ;;

          "Zowe Release Tests")
            test_file="${{ env.ZOWE_RELEAE_TESTS_FULL }}"
            dont_parse_test_server=true
            ;;
          
          *)
            echo "Something went wrong when parsing install test choice input"
            exit 1
            ;;
        esac

        if [[ -z "$dont_parse_test_server" ]]; then
          if [[ "$test_server" == "Any zzow servers" ]]; then
            test_server="zzow0"$(echo $(($RANDOM % 3 + 2)) )
          fi
          TEST_FILE_SERVER="$test_file($test_server)"
        else
          TEST_FILE_SERVER="$test_file"
        fi        

        # this is the final string that can be recognizable by the matrix processing script down below
        echo "TEST_FILE_SERVER is "$TEST_FILE_SERVER

        # sanitize all whitespaces just in case
        TEST_FILE_SERVER=$TEST_FILE_SERVER | tr -d "[:space:]"

        MATRIX_JSON_STRING="{\"include\":["
        for each_test_file_server in $(echo "$TEST_FILE_SERVER" | sed "s/;/ /g")
        do
          test_file=$(echo "$each_test_file_server" | cut -d "(" -f1)
          for test_server in $(echo "$each_test_file_server" | cut -d "(" -f2 | cut -d ")" -f1 | sed "s/,/ /g")
          do
            MATRIX_JSON_STRING="$MATRIX_JSON_STRING{\"test\":\"$test_file\",\"server\":\"marist-$test_server\"},"
          done
        done

        # remove trailing comma
        MATRIX_JSON_STRING=$(echo $MATRIX_JSON_STRING | sed 's/,$//g')

        MATRIX_JSON_STRING="$MATRIX_JSON_STRING]}"
        echo "::set-output name=matrix::$MATRIX_JSON_STRING"
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}

  cicd-test:
    runs-on: ubuntu-latest
    needs: make-matrix
    strategy:
      matrix: ${{ fromJson(needs.make-matrix.outputs.matrix) }}
      fail-fast: false
    environment: ${{ matrix.server }}
    steps:
      - name: '[Prep 1] Checkout'
        uses: actions/checkout@v2

      - name: '[Prep 2] Cache node modules'
        uses: actions/cache@v2
        with:
          # npm cache files are stored in `~/.npm` on Linux/macOS
          path: |
            ~/.npm
            ~/.nvm/.cache
            ~/.nvm/versions
          key: ${{ runner.os }}-build-cache-node-modules-${{ hashFiles('tests/installation/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-build-cache-node-modules-

      - name: '[Prep 3] Setup jFrog CLI'
        uses: jfrog/setup-jfrog-cli@v2
        env:
          JF_ENV_1: ${{ secrets.JF_ARTIFACTORY_TOKEN }}

      - name: '[Prep 4] Validate package.json'
        uses: zowe-actions/shared-actions/validate-package-json@main

      - name: '[Prep 5] Prepare workflow'
        uses: zowe-actions/shared-actions/prepare-workflow@main

      - name: '[Prep 6] Additional Prep work'
        id: more-test-prep
        run: |
          RED='\033[0;31m'
          GREEN='\033[0;32m'
          YELLOW='\033[0;33m'
          CYAN='\033[0;36m'
          NC='\033[0m'
          CURRENT_BRANCH_NEW=$(echo ${{ env.CURRENT_BRANCH }} | tr '[:upper:]' '[:lower:]' | sed "s#\/#-#g")

          function jfrog_search_latest {
            RED='\033[0;31m'
            search_pattern=$1
            if [[ -z "$search_pattern" ]]; then
              echo -e "${RED}In jfrog search latest function, search pattern is not provided" > /dev/stderr
              exit 1
            fi
            out=$(jfrog rt search --sort-by=created --sort-order=desc --limit=1 "$search_pattern" | jq -r '.[].path')
            if [[ -z "$out" ]]; then
              echo -e "${RED}Cannot find latest artifact in pattern: $search_pattern" > /dev/stderr
              exit 1
            fi
            echo $out
          }

          function jfrog_search_build {
            RED='\033[0;31m'
            search_pattern=$1
            build_name=$2
            bld_num=$3
            if [[ -z "$search_pattern" ]]; then
              echo -e "${RED}In jfrog_search_build function, search pattern is not provided" > /dev/stderr
              exit 1
            fi
            if [[ -z "$build_name" ]]; then
              echo -e "${RED}In jfrog_search_build function, build name is not provided" > /dev/stderr
              exit 1
            fi
            if [[ -z "$bld_num" ]]; then
              echo -e "${RED}In jfrog_search_build function, build number is not provided" > /dev/stderr
              exit 1
            fi
            out=$(jfrog rt search --build="$build_name/$bld_num" "$search_pattern" | jq -r '.[-1].path')
            if [[ "$out" == "null" ]]; then
              echo -e "${RED}Cannot find the artifact in pattern: $search_pattern associated with $bld_num of $build_name" > /dev/stderr
              exit 1
            fi
            echo $out
          }

          function assert_env_var {
            RED='\033[0;31m'
            envvar_name=$1
            eval envvar_val='$'$envvar_name
            if [[ -z "$envvar_val" ]]; then
              echo -e "${RED}$envvar_name" is not set > /dev/stderr
              exit 1
            fi
          }
          
          total_check=3
          if [[ "${{ matrix.test }}" == *"install-ext"* ]]; then
            ((total_check++))
          fi

          ##################################################################################################
          ### 1. Process custom-zowe-artifactory-pattern
          ##################################################################################################
          
          input_custom_zowe_art_pat_or_bldnum="${{ github.event.inputs.custom-zowe-artifactory-pattern-or-build-number }}"

          if [[ -n "$input_custom_zowe_art_pat_or_bldnum" ]]; then
            if [[ "$input_custom_zowe_art_pat_or_bldnum" =~ ^[0-9]+$ ]]; then
              echo "[Check 1 INFO] Build number $input_custom_zowe_art_pat_or_bldnum is entered"
              custom_build_number=$input_custom_zowe_art_pat_or_bldnum
              use_defaut=true
            elif [[ "$input_custom_zowe_art_pat_or_bldnum" =~ ^.+\/.+$ ]]; then
              echo "[Check 1 INFO] Custom artifactory pattern is entered, now figuring out pax or smpe..."
              custom_pattern=$input_custom_zowe_art_pat_or_bldnum

              # first extract the filename of the artifactory path to avoid string check confusion in later steps
              # filename is after the last forward slash
              file_name=${custom_pattern##*/}

              if [[ "${{ matrix.test }}" == *install-fmid.ts ]] || [[ "${{ matrix.test }}" == *install-ptf.ts ]]; then
                if [[ "$file_name" == *"zowe-smpe"*zip ]] ; then
                  # if it is valid *zowe-smpe*.zip format, and test run is smpe related, we will hornour this custom input
                  zowe_artifactory_pattern_interim="$custom_pattern"
                  echo "[Check 1 INFO] SMPE!"
                else
                  printf "${RED}[Check 1 ERROR] You are running smpe related test but the file name included in your custom zowe artifactory pattern is not a proper *zowe-smpe*.zip format\n"
                  exit 1
                fi
              else
                if [[ "$file_name" == *"zowe"* ]] && [[ "$file_name" == *pax ]]; then
                  # if it is valid *zowe*.pax format, and test run is not smpe related, we will hornour this custom input
                  zowe_artifactory_pattern_interim="$custom_pattern"
                  echo "[Check 1 INFO] PAX!"
                else
                  printf "${RED}[Check 1 ERROR] You are running pax related test but the file name included in your custom zowe artifactory pattern is not a proper *zowe*.pax format\n"
                  exit 1
                fi
              fi
            else
              printf "${RED}[Check 1 ERROR] You should enter either a build number on current running branch or a proper zowe artifactory pattern\n"
              printf "${RED}[Check 1 ERROR] Examples:\n"
              printf "${RED}[Check 1 ERROR] 491 meaning build number 491 on ${{ env.CURRENT_BRANCH }}\n"
              printf "${RED}[Check 1 ERROR] my/path/to/file\n"
              exit 1
            fi
          else
            use_defaut=true
          fi
  
          if [[ -n "$use_defaut" ]]; then
            if [[ "${{ matrix.test }}" == *install-fmid.ts ]] || [[ "${{ matrix.test }}" == *install-ptf.ts ]]; then
              zowe_artifactory_pattern_interim="${{ env.DEFAULT_ZOWE_SMPE_ARTIFACTORY_PATTERN }}"
            else
              zowe_artifactory_pattern_interim="${{ env.DEFAULT_ZOWE_PAX_ARTIFACTORY_PATTERN }}"
            fi   
          fi

          echo "[Check 1 INFO] Interim zowe artifactory pattern is $zowe_artifactory_pattern_interim"

          # note that below if-else does not always get to run the sed part, as we only replace if {branch-name} exists in the pattern,
          #   which isn't the case for customized path. In either case, $zowe_artifactory_pattern_final should be filled
          if [[ "$CURRENT_BRANCH_NEW" =~ ^v([0-9])\.x-master$ ]] ; then
            zowe_artifactory_pattern_final=$(echo "$zowe_artifactory_pattern_interim" | sed "s#{branch-name}#${BASH_REMATCH[1]}.*snapshot#g")
          elif [[ "$CURRENT_BRANCH_NEW" =~ ^v([0-9])\.x-staging$ ]] ; then
            zowe_artifactory_pattern_final=$(echo "$zowe_artifactory_pattern_interim" | sed "s#{branch-name}#${BASH_REMATCH[1]}.*staging#g")
          elif [[ "$CURRENT_BRANCH_NEW" =~ ^v([0-9])\.x-rc$ ]] ; then
            zowe_artifactory_pattern_final=$(echo "$zowe_artifactory_pattern_interim" | sed "s#{branch-name}#${BASH_REMATCH[1]}.*rc#g")
          else
            zowe_artifactory_pattern_final=$(echo "$zowe_artifactory_pattern_interim" | sed "s#{branch-name}#$CURRENT_BRANCH_NEW#g")
          fi

          echo "[Check 1 INFO] Final zowe artifactory pattern (before jfrog search) is $zowe_artifactory_pattern_final"

          if [[ -z "$custom_build_number" ]]; then
            # we will search the latest build exists on current running branch
            ZOWE_ARTIFACTORY_FINAL=$(jfrog_search_latest $zowe_artifactory_pattern_final)
          else
            # we will search according to the build number provided (on current running branch)
            ZOWE_ARTIFACTORY_FINAL=$(jfrog_search_build $zowe_artifactory_pattern_final "zowe-install-packaging/${{ env.CURRENT_BRANCH }}" $custom_build_number)
          fi

          # try to know if this SMPE artifact comes from latest or older build
          if [[ "$ZOWE_ARTIFACTORY_FINAL" == *"zowe-smpe"*zip ]]; then
            smpe_out=$(jfrog rt search "$ZOWE_ARTIFACTORY_FINAL")
            smpe_bld_name=$(echo "$smpe_out" | jq -r '.[].props."build.name"[]')
            smpe_bld_num=$(echo "$smpe_out" | jq -r '.[].props."build.number"[]')

            # encode '/' or ' ' in smpe build name as they may be confusing for jfrog REST API
            if [[ "$smpe_bld_name" == *"/"* ]]; then
              smpe_bld_name_encoded=$(echo "$smpe_bld_name" | sed "s|/|\%2F|g")
            elif [[ "$smpe_bld_name" == *"::"* ]]; then
              smpe_bld_name_encoded=$(echo "$smpe_bld_name" | sed "s| |\%20|g")
            fi
            
            latest_pax_bld_num=$(jfrog rt curl -s -XGET "/api/build/$smpe_bld_name_encoded" | jq '.buildsNumbers[0].uri' | sed "s|/||g" | sed "s|\"||g" )
      
            if [[ "$latest_pax_bld_num" != "$smpe_bld_num" ]]; then
              if [[ -z "$input_custom_zowe_art_pat_or_bldnum" ]]; then
                # when no custom input, we will throw error and fail the build
                printf "${RED}[Check 1 ERROR] Latest build $latest_pax_bld_num on current branch does not contain a SMPE artifact.\n"
                printf "${RED}[Check 1 ERROR] If you want to test install smpe, you should make sure latest build has SMPE packaged.\n"
                printf "${RED}[Check 1 ERROR] Please specify exact build number on $smpe_bld_name or any other smpe.zip artifactory path.\n"
                printf "${RED}[Check 1 ERROR] FYI latest build that contains SMPE artifact is $smpe_bld_num\n"
                exit 1
              else
                # when there is custom input, we will give warnings instead but still proceed
                printf "${YELLOW}[Check 1 WARNING] I see that you are trying to grab an older SMPE build $smpe_bld_num on $smpe_bld_name.\n"
                printf "${YELLOW}[Check 1 WARNING] However just be aware that there are more code changes (newer builds) after $smpe_bld_num, which is $latest_pax_bld_num.\n"
                printf "${YELLOW}[Check 1 WARNING] You should always test latest code on your branch unless you want to compare with older builds for regression.\n"
              fi
            fi
          fi

          # next line is just to get the pax file name - extract the part after last occurance of slash
          ZOWE_ARTIFACTORY_FINAL_FILENAME=${ZOWE_ARTIFACTORY_FINAL##*/}

          assert_env_var "ZOWE_ARTIFACTORY_FINAL"
          assert_env_var "ZOWE_ARTIFACTORY_FINAL_FILENAME"
          printf "${GREEN}[Check 1/$total_check] Zowe pax or smpe.zip artifactory full path processing complete!${NC}\n"

          ##################################################################################################
          ### 2. Process TEST_SERVER_NICKNAME
          ##################################################################################################
          TEST_SERVER=$(echo "${{ matrix.server }}" | cut -d "-" -f2)

          case $TEST_SERVER in

          "zzow02")
            TEST_SERVER_NICKNAME=marist-2
            ;;
          
          "zzow03")
            TEST_SERVER_NICKNAME=marist-3
            ;;
          
          "zzow04")
            TEST_SERVER_NICKNAME=marist-4
            ;;

          *)
            printf "${RED}[Check 2 ERROR] Something went wrong when parsing test server nickname\n"
            exit 1
            ;;
          esac

          assert_env_var "TEST_SERVER"
          assert_env_var "TEST_SERVER_NICKNAME"
          printf "${GREEN}[Check 2/$total_check] Test server name processing complete!${NC}\n"

          ##################################################################################################
          ### 3. Process custom-zowe-cli-artifactory-pattern
          ##################################################################################################
          if [[ -z "${{ github.event.inputs.custom-zowe-cli-artifactory-pattern }}" ]]; then
            zowe_cli_artifactory_pattern="${{ env.DEFAULT_ZOWE_CLI_ARTIFACTORY_PATTERN }}"
            # determine if we shall use libs-snapshot-local or libs-release-local
            if [[ "${{ env.CURRENT_BRANCH }}" == "rc" ]] || [[ "${{ env.CURRENT_BRANCH }}" == "master" ]] ; then
              zowe_cli_artifactory_pattern=$(echo "$zowe_cli_artifactory_pattern" | sed "s#PLACE_HOLDER#libs-release-local#g")
            else
              zowe_cli_artifactory_pattern=$(echo "$zowe_cli_artifactory_pattern" | sed "s#PLACE_HOLDER#libs-snapshot-local#g")
            fi
          else
            zowe_cli_artifactory_pattern="${{ github.event.inputs.custom-zowe-cli-artifactory-pattern }}"
          fi

          echo "[Check 3 INFO] Zowe cli artifactory pattern before jfrog search is $zowe_cli_artifactory_pattern"

          ZOWE_CLI_ARTIFACTORY_FINAL=$(jfrog_search_latest $zowe_cli_artifactory_pattern)
          assert_env_var ZOWE_CLI_ARTIFACTORY_FINAL
          printf "${GREEN}[Check 3/$total_check] Zowe CLI artifactory full path processing complete!${NC}\n"

          ##################################################################################################
          ### 4. Process custom-extension-list (if test-ext is selected)
          ##################################################################################################
          if [[ "${{ matrix.test }}" == *"install-ext"* ]]; then
            EXTENSION_LIST=
            if [[ -z "${{ github.event.inputs.custom-extension-list }}" ]]; then
              printf "${RED}[Check 4 ERROR] You are running install-ext test, but input 'custom-extension-list' is missing\n"
              exit 1
            fi

            # validate extension list input
            if [[ "${{ github.event.inputs.custom-extension-list }}" =~ ^([^;()]+(\([^;()]+\))*)(;[^;()]+(\([^;()]+\))*)*$ ]]; then
              echo "[Check 4 INFO] Extension list syntax validation success!"
            else
              printf "${RED}[Check 4 ERROR] Extension list validation failed\n"
              printf "${RED}[Check 4 ERROR] You must follow the format: {ext-name}[({custom-ext-pattern})][;...]\n"
              printf "${RED}[Check 4 ERROR] Example input will be\n"
              printf "${RED}[Check 4 ERROR] sample-ext;sample-ext2;sample-myext\n"
              printf "${RED}[Check 4 ERROR] sample-ext(myown/path);sample-myext\n"
              exit 1
            fi

            for each_ext in $(echo "${{ github.event.inputs.custom-extension-list }}" | sed "s/;/ /g")
            do
              echo "[Check 4 INFO] Now processing $each_ext ..."
              if [[ "$each_ext" == *"("* ]] && [[ "$each_ext" == *")"* ]] ; then
                # user provides custom artifactory pattern
                ext_name=$(echo "$each_ext" | cut -d "(" -f1)
                ext_pattern=$(echo "$each_ext" | cut -d "(" -f2 | cut -d ")" -f1)
              else
                # use default
                ext_name="$each_ext"
                ext_pattern=$(echo "${{ env.DEFAULT_ZOWE_EXT_ARTIFACTORY_PATTERN }}" | sed "s#{ext-name}#$ext_name#g")
              fi

              echo "[Check 4 INFO] extension name is $ext_name"
              echo "[Check 4 INFO] extension pattern before jfrog search is $ext_pattern"

              if [[ "$ext_pattern" != *"http"* ]]; then
                ext_full_path=$(jfrog_search_latest $ext_pattern)
              else
                ext_full_path=$ext_pattern
              fi
              echo "[Check 4 INFO] extension full path after jfrog search is $ext_full_path"
              EXTENSION_LIST="$EXTENSION_LIST$ext_name($ext_full_path);"
            done

            # remove trailing comma
            EXTENSION_LIST=$(echo $EXTENSION_LIST | sed 's/;$//g')
            assert_env_var EXTENSION_LIST
            printf "${GREEN}[Check 4/$total_check] Zowe extension list processing complete!${NC}\n"
          fi

          ##################################################################################################
          ### Set outputs
          ##################################################################################################
          echo ::set-output name=ZOWE_ARTIFACTORY_FINAL::$ZOWE_ARTIFACTORY_FINAL
          echo ::set-output name=ZOWE_ARTIFACTORY_FINAL_FILENAME::$ZOWE_ARTIFACTORY_FINAL_FILENAME
          echo ::set-output name=NODE_HOME_PATTERN::/ZOWE/node/node-${{ env.ZOS_NODE_VERSION }}-os390-s390x
          echo ::set-output name=TEST_SERVER::$TEST_SERVER
          echo ::set-output name=TEST_SERVER_NICKNAME::$TEST_SERVER_NICKNAME
          echo ::set-output name=EXTENSION_LIST::$EXTENSION_LIST
          echo ::set-output name=ZOWE_CLI_ARTIFACTORY_FINAL::$ZOWE_CLI_ARTIFACTORY_FINAL
          echo ::set-output name=ZOWE_TP_DOCKER_ARTIFACTORY_URL::$ZOWE_TP_DOCKER_ARTIFACTORY_URL

          ##################################################################################################
          ### Echo all processed outputs
          ##################################################################################################
          echo
          echo "#######################Summary of outputs:#######################"
          printf "Zowe artifactory path: ${CYAN}$ZOWE_ARTIFACTORY_FINAL${NC}\n"
          printf "Zowe artifactory file name: ${CYAN}$ZOWE_ARTIFACTORY_FINAL_FILENAME${NC}\n"
          printf "Zowe CLI artifactory path: ${CYAN}$ZOWE_CLI_ARTIFACTORY_FINAL${NC}\n"
          printf "Zowe extension list: ${CYAN}$EXTENSION_LIST${NC}\n"
          printf "Test server: ${CYAN}$TEST_SERVER${NC}\n"
          printf "Test server nickname: ${CYAN}$TEST_SERVER_NICKNAME${NC}\n"
          printf "Node home pattern on z/OS: ${CYAN}/ZOWE/node/node-${{ env.ZOS_NODE_VERSION }}-os390-s390x${NC}\n"

      - name: '[Setup 1] Project Setup 1'
        working-directory: ${{ env.INSTALL_TEST_PATH }}
        run: |
          npm ci
          npm run build

      - name: '[Setup 2] Project Setup 2'
        working-directory: ${{ env.SANITY_TEST_PATH }}
        run: |
          npm ci

      - name: '[Lint 1] Lint 1'
        timeout-minutes: 2
        working-directory: ${{ env.INSTALL_TEST_PATH }}
        run: |
          npm run lint

      - name: '[Lint 2] Lint 2'
        timeout-minutes: 2
        working-directory: ${{ env.SANITY_TEST_PATH }}
        run: |
          npm run lint

      - name: '[Download 1] Download zowe.pax or smpe-zowe.zip'
        uses: zowe-actions/shared-actions/jfrog-download@main
        with:
          source-path-or-pattern: ${{ steps.more-test-prep.outputs.ZOWE_ARTIFACTORY_FINAL }}
          default-target-path: ${{ runner.temp }}/zowe/
          extra-options: --flat=true
          expected-count: 1

      - name: '[Download 2] Download cli package'
        uses: zowe-actions/shared-actions/jfrog-download@main
        with:
          source-path-or-pattern: ${{ steps.more-test-prep.outputs.ZOWE_CLI_ARTIFACTORY_FINAL }}
          default-target-path: ${{ runner.temp }}/cli/
          extra-options: --flat=true --explode=true
          expected-count: 1

      - name: '[Install] Install CLI'
        timeout-minutes: 10
        working-directory: ${{ runner.temp }}/cli
        run: npm install -g zowe-cli*.tgz
      
      - name: '[Comment] Post comments on PR about what tests are gonna be run'
        uses: actions/github-script@v5
        id: create-comment
        if: startsWith(env.CURRENT_BRANCH, 'PR-')
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            var installTest = "${{ github.event.inputs.install-test }}"
            if (installTest == '') {  
              // if null, this is very likely to be triggered by pr auto test
              installTest = 'Convenience Pax'
            }

            var prNum='${{ env.CURRENT_BRANCH }}'.split('-')[1]

            var body=`Test workflow ${context.runNumber} is started.\n`
            body += `Running install test: ${installTest} \n`
            body += `The zowe artifact being used by this test workflow: ${{ steps.more-test-prep.outputs.ZOWE_ARTIFACTORY_FINAL }} \n`
            body += `Running on machine: ${{ steps.more-test-prep.outputs.TEST_SERVER }} \n`
            body += `Acquiring the test server lock first, please wait... \n `
            body += `ETA: unknown (This ETA will get updated once the machine lock is acquired) \n`
            body += `Link to workflow run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`
            
            const { data: comment } = await github.rest.issues.createComment({ 
              issue_number: prNum,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

            return comment.id;

      - name: '[LOCK] Lock marist servers'
        uses: zowe-actions/shared-actions/lock-resource@main
        with:
          lock-repository: ${{ github.repository }}
          github-token: ${{ secrets.GITHUB_TOKEN }}
          lock-resource-name: zowe-install-test-${{ steps.more-test-prep.outputs.TEST_SERVER }}-lock
          lock-avg-retry-interval: 60
      
      - name: '[Comment] Update comment after lock is acquired'
        uses: actions/github-script@v5
        if: steps.create-comment.outputs.result != ''
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            var installTest = "${{ github.event.inputs.install-test }}"
            var eta
            if (installTest == '') {  
              // if null, this is very likely to be triggered by pr auto test
              installTest = 'Convenience Pax'
            }

            // get ETA for each test run
            switch(installTest) {
              case 'Convenience Pax':
                eta = 27
                break;
              case 'SMPE PTF':
                eta = 47
                break;
              case 'Extensions':
                eta = 35
                break;
              case 'Keyring':
                eta = 27
                break;
              case 'z/OS node v12':
                eta = 25
                break;
              case 'z/OS node v14':
                eta = 25
                break;
              case 'z/OS node v16':
                eta = 25
                break;
              case 'Non-strict Verify External Certificate':
                eta = 25
                break;
              case 'Zowe Release Tests':
                eta = 240
                break;
              default:
            }

            var expectedTimeString
            if (eta != '') {
              const finish_time = new Date(new Date().getTime() + eta*60*1000);
              const finish_time_EST = finish_time.toLocaleString('en-CA', { timeZone: 'Canada/Eastern' }).split(', ')[1] + " EST"
              const finish_time_CET = finish_time.toLocaleString('en-EU', { timeZone: 'Europe/Prague' }).split(', ')[1] + " CET"
              const finish_time_UTC = finish_time.toLocaleString('en-GB', { timeZone: 'Europe/London' }).split(', ')[1] + " GMT"
              const finish_time_PST = finish_time.toLocaleString('en-US', { timeZone: 'America/Los_Angeles' }).split(', ')[1] + " PST"
              expectedTimeString = `Check back around: \n ${finish_time_EST}  |  ${finish_time_CET}  |  ${finish_time_UTC}  |  ${finish_time_PST} \n`
            }
            else {
              eta = 'unknown'
            }

            var body=`Test workflow ${context.runNumber} is started.\n`
            body += `Running install test: ${installTest} \n`
            body += `The zowe artifact being used by this test workflow: ${{ steps.more-test-prep.outputs.ZOWE_ARTIFACTORY_FINAL }} \n`
            body += `Running on machine: ${{ steps.more-test-prep.outputs.TEST_SERVER }} \n`
            body += `Lock acquired, start the test now, please wait... \n `
            body += `ETA: ${eta} mins \n`
            if (expectedTimeString != '') {
              body += `${expectedTimeString} \n`
            }
            body += `Result: <PENDING> (will get updated once test is finished) \n`
            body += `Link to workflow run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`
            
            github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: ${{ steps.create-comment.outputs.result }},
              body: body
            });

      - name: '[Test] Test starts from here'
        timeout-minutes: 90
        working-directory: ${{ env.INSTALL_TEST_PATH }}
        run: npm test -- --testPathPattern --detectOpenHandles dist/__tests__/$(echo "${{ matrix.test }}" | sed "s/.ts/.js/g")
        env:
          ANSIBLE_FORCE_COLOR: true
          TEST_SERVER: ${{ steps.more-test-prep.outputs.TEST_SERVER_NICKNAME }}
          ZOWE_BUILD_LOCAL: "${{ runner.temp }}/zowe/${{ steps.more-test-prep.outputs.ZOWE_ARTIFACTORY_FINAL_FILENAME }}"
          ZOWE_DOCKER_URL: ${{ steps.more-test-prep.outputs.ZOWE_TP_DOCKER_ARTIFACTORY_URL }}
          EXTENSIONS_LIST: ${{ steps.more-test-prep.outputs.EXTENSION_LIST }}
          SANITY_TEST_DEBUG: ${{ env.SANITY_TEST_DEBUG_INFORMATION }}
          DEBUG: ${{ env.INSTALL_TEST_DEBUG_INFORMATION }}
          SSH_HOST: ${{ secrets.SSH_HOST }}
          SSH_PORT: ${{ secrets.SSH_PORT }}
          SSH_USER: ${{ secrets.SSH_USER }}
          SSH_PASSWORD: ${{ secrets.SSH_PASSWORD }}
          ZOS_NODE_HOME: ${{ steps.more-test-prep.outputs.NODE_HOME_PATTERN }}
      #     # ANSIBLE_VERBOSE: -vvv

      - name: '[After Test 1] Prepare to upload test report'
        if: always()
        working-directory: ${{ env.INSTALL_TEST_PATH }}
        run: | 
          echo CURRENT_TIME=$(date +%s) >> $GITHUB_ENV
          echo TEST_NAME=$(echo "${{ matrix.test }}" | sed 's#.*\/##g') >> $GITHUB_ENV

      - name: '[After Test 2] Upload test report'
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: InstallTestReports-${{ env.TEST_NAME }}-${{ steps.more-test-prep.outputs.TEST_SERVER_NICKNAME }}-${{ github.run_id }}-${{ env.CURRENT_TIME }}
          path: ${{ env.INSTALL_TEST_PATH }}/reports/

      - name: '[Comment] Update PR comment to indicate test succeeded'
        uses: actions/github-script@v5
        if: steps.create-comment.outputs.result != '' && success()
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            var installTest = "${{ github.event.inputs.install-test }}"
            var eta
            if (installTest == '') {  
              // if null, this is very likely to be triggered by pr auto test
              installTest = 'Convenience Pax'
            }

            var body=`Test workflow ${context.runNumber} is started.\n`
            body += `Running install test: ${installTest} \n`
            body += `The zowe artifact being used by this test workflow: ${{ steps.more-test-prep.outputs.ZOWE_ARTIFACTORY_FINAL }} \n`
            body += `Running on machine: ${{ steps.more-test-prep.outputs.TEST_SERVER }} \n`
            body += `Result: SUCCESS \n`
            body += `Link to workflow run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`
            
            github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: ${{ steps.create-comment.outputs.result }},
              body: body
            });

      - name: '[Comment] Update PR comment to indicate test failed'
        uses: actions/github-script@v5
        if: steps.create-comment.outputs.result != '' && failure()
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            var installTest = "${{ github.event.inputs.install-test }}"
            var eta
            if (installTest == '') {  
              // if null, this is very likely to be triggered by pr auto test
              installTest = 'Convenience Pax'
            }

            var body=`Test workflow ${context.runNumber} is started.\n`
            body += `Running install test: ${installTest} \n`
            body += `The zowe artifact being used by this test workflow: ${{ steps.more-test-prep.outputs.ZOWE_ARTIFACTORY_FINAL }} \n`
            body += `Running on machine: ${{ steps.more-test-prep.outputs.TEST_SERVER }} \n`
            body += `Result: FAILURE \n`
            body += `Link to workflow run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`

            github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: ${{ steps.create-comment.outputs.result }},
              body: body
            });

      - name: '[Comment] Update PR comment to indicate test cancelled'
        uses: actions/github-script@v5
        if: steps.create-comment.outputs.result != '' && cancelled()
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            var installTest = "${{ github.event.inputs.install-test }}"
            var eta
            if (installTest == '') {  
              // if null, this is very likely to be triggered by pr auto test
              installTest = 'Convenience Pax'
            }

            var body=`Test workflow ${context.runNumber} is started.\n`
            body += `Running install test: ${installTest} \n`
            body += `The zowe artifact being used by this test workflow: ${{ steps.more-test-prep.outputs.ZOWE_ARTIFACTORY_FINAL }} \n`
            body += `Running on machine: ${{ steps.more-test-prep.outputs.TEST_SERVER }} \n`
            body += `Result: CANCELLED \n`
            body += `Link to workflow run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}`
            
            github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: ${{ steps.create-comment.outputs.result }},
              body: body
            });

